<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>test</title>
  <style>
    body { background: #000; color: #fff; font-family: sans-serif; text-align: center; }
    canvas { background: #111; border: 2px solid #fff; margin-top: 1rem; }
  </style>
</head>
<body>
  <h1>Unlimited Tetris</h1>
  <canvas id="tetris" width="200" height="400"></canvas>
  <p>Controls: J=←, L=→, K=soft, I=rot↻, Z=↺, A=180°, Shift=hold, Space=hard</p>
  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const canvas = document.getElementById('tetris');
      const ctx = canvas.getContext('2d');
      ctx.scale(20, 20);

      // Config
      const COLS = 10, ROWS = 20;
      const DAS = 130, ARR = 50, DCD = 50, SDF = 20, BASE = 1000;

      // State
      let arena = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
      let dropCounter = 0, lastTime = 0;
      let hold = null, canHold = true;
      let input = { left: false, right: false, soft: false, dir: 0, dcd: 0, tLeft: 0, tRight: 0 };

      const player = { pos: { x: 0, y: 0 }, mat: null, type: null, rotLast: false };

      // Pieces & kicks
      const pieces = {
        T: [[0,1,0],[1,1,1],[0,0,0]],
        J: [[2,0,0],[2,2,2],[0,0,0]],
        L: [[0,0,3],[3,3,3],[0,0,0]],
        O: [[4,4],[4,4]],
        S: [[0,5,5],[5,5,0],[0,0,0]],
        Z: [[6,6,0],[0,6,6],[0,0,0]],
        I: [[0,0,0,0],[7,7,7,7],[0,0,0,0],[0,0,0,0]]
      };

      const kicks = {
        CW: [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
        CCW: [[0,0],[1,0],[1,1],[0,-2],[1,-2]]
      };

      const randMat = () => {
        const keys = Object.keys(pieces);
        player.type = keys[Math.random() * keys.length | 0];
        return pieces[player.type].map(r => r.slice());
      };

      const reset = () => {
        player.mat = randMat();
        player.pos.y = 0;
        player.pos.x = (COLS - player.mat[0].length) / 2 | 0;
        canHold = true;
        player.rotLast = false;
      };

      const collide = (mat, p) => {
        for (let y = 0; y < p.mat.length; ++y)
          for (let x = 0; x < p.mat[y].length; ++x)
            if (p.mat[y][x] && (arena[y + p.pos.y]?.[x + p.pos.x]))
              return true;
        return false;
      };

      const merge = p => p.mat.forEach((r,y) => r.forEach((v,x) => v && (arena[p.pos.y+y][p.pos.x+x] = v)));
      const sweep = () => {
        outer: for (let y = ROWS - 1; y >= 0; --y) {
          if (arena[y].every(v => v > 0)) {
            arena.splice(y,1);
            arena.unshift(Array(COLS).fill(0));
            ++y;
          }
        }
      };

      const rotate = (m, dir) => {
        for (let y = 0; y < m.length; ++y)
          for (let x = 0; x < y; ++x)
            [m[x][y], m[y][x]] = [m[y][x], m[x][y]];
        dir > 0 ? m.forEach(r => r.reverse()) : m.reverse();
      };

      const playerRotate = dir => {
        const old = player.mat.map(r => r.slice()), x0 = player.pos.x;
        rotate(player.mat, dir);
        const kc = dir > 0 ? kicks.CW : kicks.CCW;
        for (const [dx,dy] of kc) {
          player.pos.x = x0 + dx;
          player.pos.y += dy;
          if (!collide(arena, player)) { player.rotLast = true; return; }
        }
        player.mat = old;
        player.pos.x = x0;
      };

      const detectT = () => {
        const o = player.pos;
        const corners = [[0,0],[2,0],[0,2],[2,2]];
        return corners.filter(([cx,cy]) => {
          const x = o.x+cx, y = o.y+cy;
          return y<0||x<0||x>=COLS||y>=ROWS||arena[y][x];
        }).length >= 3;
      };

      const hard = () => {
        while (!collide(arena, player)) player.pos.y++;
        player.pos.y--;
        merge(player); sweep(); reset();
      };

      const draw = () => {
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
        // arena
        arena.forEach((r,y) => r.forEach((v,x) => v && ctx.fillRect(x,y,1,1)));
        // ghost
        const g = { pos:{...player.pos}, mat:player.mat.map(r=>r.slice()) };
        while (!collide(arena,g)) g.pos.y++;
        g.pos.y--;
        ctx.globalAlpha = 0.2;
        g.mat.forEach((r,y) => r.forEach((v,x) => v && ctx.fillRect(x+g.pos.x,y+g.pos.y,1,1)));
        ctx.globalAlpha = 1;
        // player
        player.mat.forEach((r,y) => r.forEach((v,x) => v && ctx.fillRect(x+player.pos.x,y+player.pos.y,1,1)));
      };

      const move = d => { player.pos.x+=d; if(collide(arena,player)) player.pos.x-=d; };

      const update = t => {
        const dt = t - lastTime;
        lastTime = t;
        // drop
        const interval = input.soft ? BASE/SDF : BASE;
        dropCounter += dt;
        if (dropCounter > interval) {
          player.pos.y++;
          if (collide(arena,player)) {
            player.pos.y--;
            merge(player);
            if (player.type==='T' && player.rotLast && detectT()) console.log('T-SPIN!');
            sweep(); reset();
          }
          dropCounter = 0;
        }
        // handling
        if (input.dcd > 0) input.dcd -= dt;
        ['left','right'].forEach(dir => {
          if (input[dir]) {
            input[`t${dir.charAt(0).toUpperCase()+dir.slice(1)}`] += dt;
            if (input[`t${dir.charAt(0).toUpperCase()+dir.slice(1)}`] > DAS) {
              input[`t${dir.charAt(0).toUpperCase()+dir.slice(1)}`] = 0;
              move(dir==='left'? -1:1);
            }
          }
        });
        draw();
        requestAnimationFrame(update);
      };

      // input
      document.addEventListener('keydown', e => {
        switch(e.key.toLowerCase()){
          case 'j': input.left = true; move(-1); input.dcd = input.dir===1?DCD:input.dcd; input.dir=-1; break;
          case 'l': input.right= true; move(1); input.dcd = input.dir===-1?DCD:input.dcd; input.dir=1; break;
          case 'k': input.soft = true; break;
          case 'i': playerRotate(1); break;
          case 'z': playerRotate(-1); break;
          case 'a': playerRotate(1); playerRotate(1); break;
          case 'shift':
            if(canHold){ [player.mat,hold]=[hold||player.mat,player.mat]; reset(); canHold=false; }
            break;
          case ' ': hard(); break;
        }
      });
      document.addEventListener('keyup', e => {
        if (e.key==='j') input.left=false;
        if (e.key==='l') input.right=false;
        if (e.key==='k') input.soft=false;
      });

      reset(); update();
    });
  </script>
</body>
</html>
